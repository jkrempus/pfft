<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>pfft.pfft</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/underscore-min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.cookie.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div>
<div id="explorerclient" class="shaded_box">
</div>
<div id="loadingdoc">Loading...</div>
<div id="content" class="shaded_box">
    <div id="docbody">
        <h2 class="moduletitle">pfft.pfft</h2>
        <!-- Generated by Ddoc from ../../pfft/pfft.d -->
<br>

<dl>
<dt><span class="decl">class 
<span class="currsymbol">Fft</span>(T);
</span></dt>
<dd>A class for calculating discrete fourier transform. The methods of this class
use split format for complex data. This means that a complex data set is
represented as two arrays - one for the real part and one for the imaginary
part. An instance of this class can only be used for transforms of one
particular size. The template parameter is the floating point type that the
methods of the class will operate on.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color="#008">import</font> std.stdio, std.conv, std.exception;
<font color="#008">import</font> pfft.pfft;

<font color="#008">void</font> main(string[] args)
{
    <font color="#008">auto</font> n = to!<font color="#008">int</font>(args[1]);
    enforce((n &amp; (n-1)) == 0, <font color="#A31515">"N must be a power of two."</font>);

    <font color="#008">alias</font> <u>Fft</u>!<font color="#008">float</font> F;

    <font color="#008">auto</font> f = <font color="#008">new</font> F(n);

    <font color="#008">auto</font> re = F.allocate(n);
    <font color="#008">auto</font> im = F.allocate(n);

    <font color="#008">foreach</font>(i, _; re)
        readf(<font color="#A31515">"%s %s\n"</font>, &amp;re[i], &amp;im[i]);

    f.fft(re, im);

    <font color="#008">foreach</font>(i, _; re)
        writefln(<font color="#A31515">"%s\t%s"</font>, re[i], im[i]);
}
</pre>
<br><br>


<dl>
<dt><span class="decl">this(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>The Fft constructor. The parameter is the size of data sets that <strong><code>fft</code></strong> and
<strong><code>ifft</code></strong> will operate on. I will refer to this number as <span class="funcparam">n</span> in the rest of the
documentation for this class.Tables used in fft and ifft are calculated in the
constructor.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">fft</span>(T[] <span class="funcparam">re</span>, T[] <span class="funcparam">im</span>);
</span></dt>
<dd>Calculates discrete fourier transform. <i><span class="funcparam">re</span></i> should contain the real
part of the data and <i><span class="funcparam">im</span></i> the imaginary part of the data. The method
operates in place - the result is saved back to <i><span class="funcparam">re</span></i> and <i><span class="funcparam">im</span></i>.
Both arrays must be properly aligned - to obtain a properly aligned array you can
use <strong><code>allocate</code></strong>.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">ifft</span>(T[] <span class="funcparam">re</span>, T[] <span class="funcparam">im</span>);
</span></dt>
<dd>Calculates inverse discrete fourier transform scaled by n. The arguments have
the same role as they do in <strong><code>fft</code></strong>.<br><br>

</dd>

<dt><span class="decl">T[] 
<span class="currsymbol">allocate</span>(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>Allocates an array that is aligned properly for use with <strong><code>fft</code></strong>, <strong><code>ifft</code></strong> and
<strong><code>scale</code></strong> methods.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">scale</span>(T[] <span class="funcparam">data</span>, T <span class="funcparam">k</span>);
</span></dt>
<dd>Scales an array <span class="funcparam">data</span> by factor <span class="funcparam">k</span>. The array must be properly aligned. To obtain
a properly aligned array, use <strong><code>allocate</code></strong>.<br><br>

</dd>
</dl>
</dd>

<dt><span class="decl">class 
<span class="currsymbol">Rfft</span>(T);
</span></dt>
<dd>A class for calculating real discrete fourier transform. The methods of this
class use split format for complex data. This means that complex data set is
represented as two arrays - one for the real part and one for the imaginary
part. An instance of this class can only be used for transforms of one
particular size. The template parameter is the floating point type that the
methods of the class will operate on.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color="#008">import</font> std.stdio, std.conv, std.exception;
<font color="#008">import</font> pfft.pfft;

<font color="#008">void</font> main(string[] args)
{
    <font color="#008">auto</font> n = to!<font color="#008">int</font>(args[1]);
    enforce((n &amp; (n-1)) == 0, <font color="#A31515">"N must be a power of two."</font>);

    <font color="#008">alias</font> <u>Rfft</u>!<font color="#008">float</font> F;

    <font color="#008">auto</font> f = <font color="#008">new</font> F(n);

    <font color="#008">auto</font> data = F.allocate(n);

    <font color="#008">foreach</font>(<font color="#008">ref</font> e; data)
        readf(<font color="#A31515">"%s\n"</font>, &amp;e);

    f.rfft(data);

    <font color="#008">foreach</font>(i; 0 .. n / 2 + 1)
        writefln(<font color="#A31515">"%s\t%s"</font>, data[i], (i == 0 || i == n / 2) ? 0 : data[i]);
}
</pre>
<br><br>


<dl>
<dt><span class="decl">this(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>The Rfft constructor. The parameter is the size of data sets that <strong><code>rfft</code></strong> will
operate on. I will refer to this number as <span class="funcparam">n</span> in the rest of the documentation
for this class. All tables used in rfft are calculated in the constructor.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">rfft</span>(T[] <span class="funcparam">data</span>);
</span></dt>
<dd>Calculates discrete fourier transform of the real valued sequence in <span class="funcparam">data</span>.
The method operates in place. When the method completes, <span class="funcparam">data</span> contains the
result. First <i>n / 2 + 1</i> elements contain the real part of the result and
the rest contains the imaginary part. Imaginary parts at position 0 and
<i>n / 2</i> are known to be equal to 0 and are not stored, so the content of
<span class="funcparam">data</span> looks like this:
<br><br>
<strong><code>r(0), r(1), ... r(n / 2), i(1), i(2), ... i(n / 2 - 1)</code></strong>
<br>

<br>

The elements of the result at position greater than n / 2 can be trivially
calculated from the relation <i>DFT(f)[i] = DFT(f)[n - i]*</i> that holds
because the input sequence is real.
<br>

<br>

The length of the array must be equal to n and the array must be properly
aligned. To obtain a properly aligned array you can use <strong><code>allocate</code></strong>.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">irfft</span>(T[] <span class="funcparam">data</span>);
</span></dt>
<dd>Calculates the inverse of <strong><code>rfft</code></strong>, scaled by n (You can use <strong><code>scale</code></strong>
to normalize the result). Before the method is called, <span class="funcparam">data</span> should contain a
complex sequence in the same format as the result of <strong><code>rfft</code></strong>. It is
assumed that the input sequence is a discrete fourier transform of a real
valued sequence, so the elements of the input sequence not stored in <span class="funcparam">data</span>
can be calculated from <i>DFT(f)[i] = DFT(f)[n - i]*</i>. When the method
completes, the array contains the real part of the inverse discrete fourier
transform. The imaginary part is known to be equal to 0.
<br><br>
The length of the array must be equal to n and the array must be properly
aligned. To obtain a properly aligned array you can use <strong><code>allocate</code></strong>.<br><br>

</dd>

<dt><span class="decl">alias 
<span class="currsymbol">allocate</span>;
</span></dt>
<dd>An alias for Fft!T.
<span class="currsymbol">allocate</span><br><br>

</dd>

<dt><span class="decl">alias 
<span class="currsymbol">scale</span>;
</span></dt>
<dd>An alias for Fft!T.
<span class="currsymbol">scale</span><br><br>

</dd>
</dl>
</dd>
</dl>

        <span id="docbody_end"/>
    </div>
</div>
<!--    <div id="docfooter">
            Page was generated with
            <a href="https://github.com/eldar/candydoc"><img src="candydoc/img/logo.png" style="vertical-align:middle; position:relative; top:-1px"></a>
            on Thu Jul 19 05:40:35 2012

        </td>-->
<span id="packages" class="emptytag">
	<span class="emptytag module" modulename="pfft.stdapi"></span>
	<span class="emptytag module" modulename="pfft.pfft"></span>
	<span class="emptytag module" modulename="pfft.clib"></span></span>
</body></html>


