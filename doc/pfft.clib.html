<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>pfft.clib</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/underscore-min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.min.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/jquery.cookie.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div>
<div id="explorerclient" class="shaded_box">
</div>
<div id="loadingdoc">Loading...</div>
<div id="content" class="shaded_box">
    <div id="docbody">
        <h2 class="moduletitle">pfft.clib</h2>
        <!-- Generated by Ddoc from clib.d -->
Functions in this module can be used from both C and D. To use them from C,
include pfft.h. Only the functions that operate on floats are listed here. To
calculate fft of doubles or reals (long doubles in C), just replace the "f"
suffix on functions and "F" on types with "d" or "l" on functions and "D" or
"L" on types.
<br><br>
Example of using this module from C:
<pre class="d_code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pfft.h&gt;

<font color="#008">int</font> main(<font color="#008">int</font> argc, <font color="#008">char</font> **argv)
{
    <font color="#008">int</font> n = atoi(argv[1]);
    PfftTableF tab = pfft_table_f(n, 0);
    <font color="#008">float</font> *re = pfft_allocate_f(n);
    <font color="#008">float</font> *im = pfft_allocate_f(n);

    <font color="#008">int</font> i;
    <font color="#008">for</font>(i = 0; i &lt; n; i++)
        scanf(<font color="#A31515">"%f %f"</font>, re + i, im + i);

    pfft_fft_f(re, im, tab);

    <font color="#008">for</font>(i = 0; i &lt; n; i++)
        printf(<font color="#A31515">"%f %f\n"</font>, re[i], im[i]);

    pfft_free_f(re);
    pfft_free_f(im);
    pfft_table_free_f(tab);
}
</pre>
<br><br>


<dl>
<dt><span class="decl">struct 
<span class="currsymbol">PfftTableF</span>;
</span></dt>
<dd>A struct that contains precomputed tables used in <strong><code>pfft_fft_f</code></strong> and <strong><code>pfft_ifft_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">PfftTableF 
<span class="currsymbol">pfft_table_f</span>(size_t <span class="funcparam">n</span>, void* <span class="funcparam">mem</span>);
</span></dt>
<dd>Returns an instance <strong><code>PfftTableF</code></strong> suitable for computing discrete fourier
transforms on input sequences of length <span class="funcparam">n</span> (I will also use the name <span class="funcparam">n</span>
to refer to the length of the input sequence in the function descriptions below).
If <b>null</b> is passed as <span class="funcparam">mem</span>, the function will
alocate the needed memory. In this case you should call <strong><code>pfft_table_free_f</code></strong> on
the returned instance of <strong><code>PfftTableF</code></strong> when you are done with it. If a value
different from <b>null</b> is passed as <span class="funcparam">mem</span>, the function does not allocate and
uses memory at <span class="funcparam">mem</span> instead. In this case there should be at least
<strong><code>pfft_table_size_bytes_f</code></strong> bytes of memory available at <span class="funcparam">mem</span> and it should be
properly aligned. To find out what the proper alignment is, use <strong><code>pfft_alignment_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">size_t 
<span class="currsymbol">pfft_table_size_bytes_f</span>(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>This function returns the size of a memory block needed by <strong><code>pfft_table_f</code></strong>. See
the description of <strong><code>pfft_table_f</code></strong> above.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">pfft_table_free_f</span>(PfftTableF <span class="funcparam">table</span>);
</span></dt>
<dd>Frees the memory used by a <strong><code>PfftTableF</code></strong> instance. If you passed a pointer
different from <b>null</b> as a second parameter to <strong><code>pfft_table_f</code></strong> when creating
the instance of <strong><code>PfftTableF,</code></strong> you should not call this function on it -
you should take care of dealocating memory you used yoursef instead.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">pfft_fft_f</span>(float* <span class="funcparam">re</span>, float* <span class="funcparam">im</span>, PfftTableF <span class="funcparam">table</span>);
</span></dt>
<dd>Computes discrete fourier transform. <span class="funcparam">re</span> should contain the real
part of the input sequence and <span class="funcparam">im</span> the imaginary part of the sequence. The
length of the input sequence should be equal to the number that was passed
to <strong><code>pfft_table_f</code></strong> when creating <span class="funcparam">table</span>. The method operates in place - the
result is saved back to <i><span class="funcparam">re</span></i> and <i><span class="funcparam">im</span></i>. Both arrays must
be properly aligned. An easy way to obtain a properly aligned block of memory
is to use <strong><code>pfft_allocate_f</code></strong>. If you want to take care of memory allocation in
some other way, you should make sure that the addresses <span class="funcparam">re</span> and <span class="funcparam">im</span> are multiples
of the number returned by <strong><code>pfft_alignment_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">pfft_ifft_f</span>(float* <span class="funcparam">re</span>, float* <span class="funcparam">im</span>, PfftTableF <span class="funcparam">table</span>);
</span></dt>
<dd>This function is an inverse of <strong><code>pfft_fft_f,</code></strong> scaled by n. See the
description of <strong><code>pfft_fft_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">struct 
<span class="currsymbol">PfftRTableF</span>;
</span></dt>
<dd>A struct that contains precomputed tables used in <strong><code>pfft_rfft_f</code></strong> and <strong><code>pfft_irfft_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">PfftRTableF 
<span class="currsymbol">pfft_rtable_f</span>(size_t <span class="funcparam">n</span>, void* <span class="funcparam">mem</span>);
</span></dt>
<dd>This function is used in the same way as <strong><code>pfft_table_f,</code></strong> the only difference is
that it returns an instance of struct <strong><code>PfftRTableF</code></strong>.<br><br>

</dd>

<dt><span class="decl">size_t 
<span class="currsymbol">pfft_rtable_size_bytes_f</span>(size_t <span class="funcparam">n</span>);
</span></dt>
<dd>This function returns the size of a memory block needed by <strong><code>pfft_rtable_f</code></strong>.
See the descriptions of <strong><code>pfft_rtable_f</code></strong> and <strong><code>pfft_table_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">pfft_rtable_free_f</span>(PfftRTableF <span class="funcparam">table</span>);
</span></dt>
<dd>This function is used in the same was as <strong><code>pfft_table_free_f,</code></strong> the only difference
is that it takes an instance of struct <strong><code>PfftRTableF</code></strong> as a parameter.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">pfft_rfft_f</span>(float* <span class="funcparam">data</span>, PfftRTableF <span class="funcparam">table</span>);
</span></dt>
<dd>Calculates discrete fourier transform of the real valued sequence in <span class="funcparam">data</span>.
The method operates in place. When the method completes, <span class="funcparam">data</span> contains the
result. First <i>n / 2 + 1</i> elements contain the real part of the result and
the rest contains the imaginary part. Imaginary parts at position 0 and
<i>n / 2</i> are known to be equal to 0 and are not stored, so the content of
<span class="funcparam">data</span> looks like this:
<br><br>
<strong><code>r(0), r(1), ... r(n / 2), i(1), i(2), ... i(n / 2 - 1)</code></strong>
<br>

<br>

The elements of the result at position greater than <i>n / 2</i> can be trivially
calculated from the relation <i>DFT(f)[i] = DFT(f)[n - i]*</i> that holds
because the input sequence is real.
<br>

<br>

The length of the array must be equal to n and the array must be properly
aligned. To obtain a properly aligned array you can use <strong><code>pfft_allocate_f</code></strong>.
If you want to take care of memory allocation in some other way, you should
make sure that the address <span class="funcparam">data</span> is a multiple of the number returned by
<strong><code>pfft_alignment_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">pfft_irfft_f</span>(float* <span class="funcparam">data</span>, PfftRTableF <span class="funcparam">table</span>);
</span></dt>
<dd>Calculates the inverse of <strong><code>pfft_rfft_f</code></strong>, scaled by n. Before the method
is called, <span class="funcparam">data</span> should contain a complex sequence in the same format as the
result of <strong><code>pfft_rfft_f</code></strong>. It is assumed that the input sequence is a discrete
fourier transform of a real valued sequence, so the elements of the input
sequence not stored in <span class="funcparam">data</span> can be calculated from
<i>DFT(f)[i] = DFT(f)[n - i]*</i>. When the method completes, the array
contains the real part of the inverse discrete fourier transform of the
input sequence, scaled by n. The imaginary part is known to be equal to zero.
<br><br>
The length of the array must be equal to n and the array must be properly
aligned. To obtain a properly aligned array you can use <strong><code>pfft_allocate_f</code></strong>.
If you want to take care of memory allocation in some other way, you should
make sure that the address <span class="funcparam">data</span> is a multiple of the number returned by
<strong><code>pfft_alignment_f</code></strong>.<br><br>

</dd>

<dt><span class="decl">size_t 
<span class="currsymbol">pfft_alignment_f</span>(size_t <span class="funcparam">nbytes</span>);
</span></dt>
<dd>Returns appropriate alignment for use with functions in this module for a
memory block of size <span class="funcparam">nbytes</span>.<br><br>

</dd>

<dt><span class="decl">float* 
<span class="currsymbol">pfft_allocate_f</span>(size_t <span class="funcparam">nelements</span>);
</span></dt>
<dd>Returns a pointer to an array of size <span class="funcparam">nelements</span>, aligned apropriately for
use with functions in this module.<br><br>

</dd>

<dt><span class="decl">void 
<span class="currsymbol">pfft_free_f</span>(float* <span class="funcparam">p</span>);
</span></dt>
<dd>Frees memory allocated with <strong><code>pfft_allocate_f</code></strong>.<br><br>

</dd>
</dl>

        <span id="docbody_end"/>
    </div>
</div>
<!--    <div id="docfooter">
            Page was generated with
            <a href="https://github.com/eldar/candydoc"><img src="candydoc/img/logo.png" style="vertical-align:middle; position:relative; top:-1px"></a>
            on Thu Jul 19 05:14:23 2012

        </td>-->
<span id="packages" class="emptytag">
	<span class="emptytag module" modulename="pfft.stdapi"></span>
	<span class="emptytag module" modulename="pfft.pfft"></span>
	<span class="emptytag module" modulename="pfft.clib"></span></span>
</body></html>


